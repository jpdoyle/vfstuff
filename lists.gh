#ifndef VFUTIL_LISTS_GH
#define VFUTIL_LISTS_GH

#include <list.gh>
#include <assoclist.gh>
#include <permutations.gh>
#include "util.gh"

#define ASSOC(s,t) list<pair<s,t> >

lemma_auto(mem(x,reverse(l)))
void mem_reverse<t>(t x,list<t> l)
    requires true;
    ensures  mem(x,reverse(l)) == mem(x,l);
{ LIST_INDUCTION(l,xs,mem_reverse(x,xs)) }

lemma_auto(remove(pair(k,v),l))
void remove_assoc_of_distinct<s,t>(s k, t v, ASSOC(s,t) l);
    requires distinct(keys(l)) && mem(pair(k,v),l);
    ensures  remove(pair(k,v),l) == remove_assoc(k,l);

lemma_auto(remove(x,l))
void remove_nonmem<t>(t x, list<t> l)
    requires true;
    ensures  (remove(x,l) == l) == !mem(x,l);
{ LIST_INDUCTION(l, xs, remove_nonmem(x, xs)) }

lemma_auto(remove(x,l))
void remove_distinct<t>(t x, list<t> l)
    requires !!distinct(l);
    ensures  !mem(x,remove(x,l));
{ LIST_INDUCTION(l, xs, remove_distinct(x, xs)) }

lemma_auto(mem(x,remove(y,l)))
void mem_remove<t>(t x, t y, list<t> l)
    requires !!mem(x,remove(y,l));
    ensures  !!mem(x,l);
{ LIST_INDUCTION(l, xs, if(mem(x,remove(y,xs))) mem_remove(x, y, xs)) }

lemma_auto(mem(x,remove(y,l)))
void remove_other<t>(t x, t y, list<t> l)
    requires x != y;
    ensures  mem(x,remove(y,l)) == mem(x,l);
{ LIST_INDUCTION(l, xs, remove_other(x, y, xs)) }

lemma
void remove_exact<t>(t x, t y, list<t> l)
    requires !!mem(x,l) &*& !mem(x,remove(y,l));
    ensures  x == y;
{
  switch(l) {
  case nil:
  case cons(v,vs):
    if(x != v) { remove_exact(x,y,vs); }
  }
}

lemma_auto(remove(x,remove(x,l)))
void remove_idempotent<t>(t x, list<t> l)
    requires !!distinct(l);
    ensures  remove(x,l) == remove(x,remove(x,l));
{ LIST_INDUCTION(l, xs, remove_idempotent(x, xs)) }

lemma_auto(is_permutation(keys(a),keys(b)))
void keys_permutation<s,t>(ASSOC(s,t) a, ASSOC(s,t) b);
    requires is_permutation(a,b) && distinct(keys(a))
        &&   distinct(keys(b));
    ensures  !!is_permutation(keys(a),keys(b));


lemma_auto(length(l)) void nil_length_auto<t>(list<t> l)
    requires true;
    ensures  (length(l) == 0) == (l == nil);
{ TRIVIAL_LIST(l) }


lemma_auto(tail(l)) void cons_head_tail<t>(list<t> l)
    requires l != nil;
    ensures  l == cons(head(l),tail(l));
{ TRIVIAL_LIST(l) }

lemma_auto(drop(n,append(p,s))) void drop_of_append<t>(
        int n, list<t> p, list<t> s);
    requires n == length(p);
    ensures drop(n,append(p,s)) == s;

lemma_auto(take(n,append(p,s))) void take_of_append<t>(
        int n, list<t> p, list<t> s);
    requires n == length(p);
    ensures take(n,append(p,s)) == p;

lemma_auto(all_eq(drop(n,l),x)) void all_eq_drop<t>(list<t> l, int n,
        t x);
    requires n >= 0 && n <= length(l) && all_eq(l,x);
    ensures  !!all_eq(drop(n,l),x);

lemma_auto(drop(n,drop(m,l)))
void drop_n_of_drop_m<t>(int n, int m, list<t> l);
    requires n >= 0 && m >= 0;
    ensures  drop(n,drop(m,l)) == drop(n+m,l);

lemma_auto(drop(n,take(m,l)))
void drop_n_of_take_m<t>(int n, int m, list<t> l);
    requires n >= 0 && m >= 0 && m >= n && m <= length(l);
    ensures  drop(n,take(m,l)) == take(m-n,drop(n,l));

lemma_auto(take(n,take(m,l)))
void take_n_of_take_m<t>(int n, int m, list<t> l);
    requires n >= 0 && m >= 0 && m >= n && m <= length(l);
    ensures  take(n,take(m,l)) == take(n,l);

lemma_auto(all_eq(take(n,l),v))
void all_eq_take<t>(int n, list<t> l, t v);
    requires n >= 0 && n <= length(l) && all_eq(l,v);
    ensures  !!all_eq(take(n,l),v);

lemma //_auto(is_permutation(a,b))
void permutation_length<t>(list<t> a, list<t> b);
    requires !!is_permutation(a,b);
    ensures  length(a) == length(b);

lemma_auto(remove(x,append(a,b)))
void remove_append<t>(t x, list<t> a, list<t> b);
    requires !!mem(x,a);
    ensures  remove(x,append(a,b)) == append(remove(x,a),b);

lemma_auto(is_permutation(a,b))
void permutation_symm<t>(list<t> a, list<t> b);
    requires true;
    ensures  is_permutation(a,b) == is_permutation(b,a);

//lemma
//void permutation_disjoint<t>(list<t> a, list<t> b, list<t> c)
//    requires !!is_permutation(a,b);
//    ensures  distinct(append(a,c)) == distinct(append(b,c));
//{
//    switch(a) {
//    case nil: return;
//    case cons(x,xs):
//        permutation_length(xs,remove(x,b));
//    }
//}

//lemma_auto(is_permutation(append(xs,cons(x,ys)),
//            append(cons(x,xs),ys)))
//void permutation_cons_swap<t>(t x, list<t> xs, list<t> ys)
//    requires distinct(xs) && distinct(ys);
//    ensures  !!is_permutation(append(xs,cons(x,ys)),
//            append(cons(x,xs),ys));
//{
//    assert append(cons(x,xs),ys) == cons(x,append(xs,ys));
//    assert remove(x,append(cons(x,xs),ys)) == append(xs,ys);
//    disjoint_append(cons(x,xs),ys);
//    assert !distinct(cons(x,xs));
//    assert !mem(x,xs);
//    assert remove(x,append(xs,cons(x,ys))) == append(xs,ys);
//    assert  !!is_permutation(append(xs,cons(x,ys)),
//            append(cons(x,xs),ys));
//}

fixpoint int sum(list<int> l) {
    switch(l) {
    case nil: return 0;
    case cons(x,xs): return x + sum(xs);
    }
}

lemma void nonneg_sum(list<int> l)
    requires !!forall(l,(ge_than)(0));
    ensures  sum(l) >= 0;
{ LIST_INDUCTION(l,xs,nonneg_sum(xs)) }

lemma //_auto(filter((constf)(true),l))
void filter_id<t>(list<t> l)
    requires true;
    ensures  filter((constf)(true),l) == l;
{ LIST_INDUCTION(l,xs,filter_id(xs)) }

lemma void nonneg_filter_sum(list<int> l, fixpoint(int,bool) f)
    requires !!forall(l,(ge_than)(0));
    ensures  sum(filter(f,l)) <= sum(l);
{ LIST_INDUCTION(l,xs,nonneg_filter_sum(xs,f)) }

lemma void forall_filter<t>(list<t> l, fixpoint(t,bool) p,
        fixpoint(t,bool) f)
    requires !!forall(l,p);
    ensures  !!forall(filter(f,l),p);
{ LIST_INDUCTION(l,xs,forall_filter(xs,p,f)) }

lemma void forall_remove<t>(list<t> l, fixpoint(t,bool) p,
        t x)
    requires !!forall(l,p);
    ensures  !!forall(remove(x,l),p);
{ LIST_INDUCTION(l,xs,forall_remove(xs,p,x)) }

lemma t filter_diff<t>(fixpoint(t,bool) f1, fixpoint(t,bool) f2,
        list<t> l);
    requires filter(f1,l) != filter(f2,l);
    ensures  !!mem(result,l) &*& f1(result) != f2(result);

lemma t filter_effect<t>(fixpoint(t,bool) f, list<t> l);
    requires filter(f,l) != l;
    ensures  !!mem(result,l) &*& !f(result);

fixpoint list<t> repeat<t>(t v, nat n) {
    switch(n) {
    case zero:     return {};
    case succ(n0): return cons(v,repeat(v,n0));
    }
}

lemma_auto(length(repeat(v,n))) void repeat_len<t>(t v, nat n)
    requires true;
    ensures  length(repeat(v,n)) == int_of_nat(n);
{ NAT_INDUCTION(n,n0,repeat_len(v,n0)) }

lemma_auto(mem(x,repeat(v,n))) void mem_repeat<t>(t x, t v, nat n);
    requires !!mem(x,repeat(v,n));
    ensures  x == v;

fixpoint list<int> indices_of_inner<t>(t v, list<t> l, int base) {
    switch(l) {
    case nil: return {};
    case cons(x,xs):
        return (x == v ? cons(base, indices_of_inner(v,xs,base+1))
                       : indices_of_inner(v,xs,base+1));
    }
}

fixpoint list<int> indices_of<t>(t v, list<t> l) {
    return indices_of_inner(v,l,0);
}

lemma
void indices_of_inner_correct<t>(t v, list<t> l, int b, int i);
    requires true;
    ensures  mem(i,indices_of_inner(v,l,b))
        ==   (nth_of(i-b,l) == some(v));

lemma_auto(mem(i,indices_of_inner(v,l,b)))
void indices_of_inner_correct_auto<t>(t v, list<t> l, int b, int i);
    requires !!mem(i,indices_of_inner(v,l,b));
    ensures  (nth_of(i-b,l) == some(v));

lemma
void indices_of_inner_bounds<t>(t v, list<t> l, int b, int i);
    requires !!mem(i,indices_of_inner(v,l,b));
    ensures  i >= b &*& i < b+length(l);

lemma_auto(mem(i,indices_of_inner(v,l,b)))
void indices_of_inner_bounds_auto1<t>(t v, list<t> l, int b, int i);
    requires !!mem(i,indices_of_inner(v,l,b));
    ensures  i >= b;

lemma_auto(mem(i,indices_of_inner(v,l,b)))
void indices_of_inner_bounds_auto2<t>(t v, list<t> l, int b, int i);
    requires !!mem(i,indices_of_inner(v,l,b));
    ensures  i < b+length(l);

lemma_auto(indices_of_inner(v,append(a,b),i))
void indices_of_inner_append<t>(t v, list<t> a, list<t> b, int i)
    requires true;
    ensures  indices_of_inner(v,append(a,b),i)
        ==   append(indices_of_inner(v,a,i),
                    indices_of_inner(v,b,i+length(a)));
{ LIST_INDUCTION(a,axs, indices_of_inner_append(v,axs,b,i+1)) }

fixpoint int maximum(list<int> l) {
    switch(l) {
    case nil: return 0;
    case cons(x,xs):
        return switch(xs) {
        case nil: return x;
        case cons(v,vs): return max_of(x,maximum(xs));
        };
    }
}

lemma void maximum_correct(int x, list<int> l);
    requires !!mem(x,l);
    ensures  !!mem(maximum(l),l) &*& maximum(l) >= x;

lemma_auto(mem(maximum(cons(x,xs)),cons(x,xs)))
void maximum_is_mem(int x, list<int> xs)
    requires true;
    ensures  !!mem(maximum(cons(x,xs)),cons(x,xs));
{
  switch(xs) {
  case nil:
  case cons(v,vs):
    maximum_is_mem(v,vs);
  }
}

lemma void maximum_remove(int x,list<int> l);
    requires !!mem(x,l) &*& length(l) > 1;
    ensures  maximum(l) == max_of(x,maximum(remove(x,l)));

lemma void maximum_permutation(list<int> a,list<int> b);
    requires !!is_permutation(a,b);
    ensures  maximum(a) == maximum(b);

lemma_auto(maximum(cons(a,cons(b,l))))
void maximum_swap(int a, int b, list<int> l)
    requires true;
    ensures  maximum(cons(a,cons(b,l)))
        ==   maximum(cons(b,cons(a,l)));
{ TRIVIAL_LIST(l) }

lemma void index_of_witness<t>(int i,t x,list<t> l)
    requires !!distinct(l) &*& nth_of(i,l) == some(x);
    ensures  index_of(x,l) == i;
{ LIST_INDUCTION(l,xs,if(i > 0) index_of_witness(i-1,x,xs)) }

lemma_auto(length(reverse(l)))
void length_reverse<t>(list<t> l)
    requires true;
    ensures  length(reverse(l)) == length(l);
{ LIST_INDUCTION(l,xs,length_reverse(xs)) }

#endif

