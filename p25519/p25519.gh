#ifndef VFUTIL_P25519_GH
#define VFUTIL_P25519_GH

#include "../util.gh"
#include "../numtheo.gh"
#include "../finfield.gh"

fixpoint int P25519() {
    return pow_nat(2,nat_of_int(255)) - 19;
}

lemma void p25519_formula();
    requires true;
    ensures  P25519
        ==   pow_nat(pow_nat(2,N15),N16)*pow_nat(2,N15) - 19;

lemma pratt_cert p25519_pratt();
    requires true;
    ensures  pratt_certificate(result,1,_,P25519);

lemma void p25519_is_prime();
    requires true;
    ensures  !!is_prime(P25519);

#define DECLARE_2_NATS(prev,pref) \
    nat n##pref##0 = succ(prev); \
    nat n##pref##1 = succ(n##pref##0);

#define DECLARE_4_NATS(prev,pref) \
    DECLARE_2_NATS(prev,pref##0) \
    DECLARE_2_NATS(n##pref##0##1,pref##1)

#define DECLARE_8_NATS(prev,pref) \
    DECLARE_4_NATS(prev,pref##0) \
    DECLARE_4_NATS(n##pref##0##11,pref##1)

#define DECLARE_16_NATS(prev,pref) \
    DECLARE_8_NATS(prev,pref##0) \
    DECLARE_8_NATS(n##pref##0##111,pref##1)

#define DECLARE_32_NATS(prev,pref) \
    DECLARE_16_NATS(prev,pref##0) \
    DECLARE_16_NATS(n##pref##0##1111,pref##1)

#define DECLARE_64_NATS(prev,pref) \
    DECLARE_32_NATS(prev,pref##0) \
    DECLARE_32_NATS(n##pref##0##11111,pref##1)

#define DECLARE_128_NATS(prev,pref) \
    DECLARE_64_NATS(prev,pref##0) \
    DECLARE_64_NATS(n##pref##0##111111,pref##1)

#define DECLARE_256_NATS(prev,pref) \
    DECLARE_128_NATS(prev,pref##0) \
    DECLARE_128_NATS(n##pref##0##1111111,pref##1)

#define DECLARE_512_NATS(prev,pref) \
    DECLARE_256_NATS(prev,pref##0) \
    DECLARE_256_NATS(n##pref##0##11111111,pref##1)

#define DECLARE_2_SQUARES(P,g,prev,pref) \
    int pref##0 = ((prev)*(prev))%P; \
    nat n_##pref##0 = succ(n_##prev); \
    int p2_##pref##0 = 2*p2_##prev; \
    int pref##1 = ((pref##0)*(pref##0))%P; \
    nat n_##pref##1 = succ(n_##pref##0); \
    int p2_##pref##1 = 2*p2_##pref##0;

#define DECLARE_4_SQUARES(P,g,prev,pref) \
    DECLARE_2_SQUARES(P,g,prev,pref##0) \
    DECLARE_2_SQUARES(P,g,pref##01,pref##1)

#define DECLARE_8_SQUARES(P,g,prev,pref) \
    DECLARE_4_SQUARES(P,g,prev,pref##0) \
    DECLARE_4_SQUARES(P,g,pref##011,pref##1)

#define DECLARE_16_SQUARES(P,g,prev,pref) \
    DECLARE_8_SQUARES(P,g,prev,pref##0) \
    DECLARE_8_SQUARES(P,g,pref##0111,pref##1)

#define DECLARE_32_SQUARES(P,g,prev,pref) \
    DECLARE_16_SQUARES(P,g,prev,pref##0) \
    DECLARE_16_SQUARES(P,g,pref##01111,pref##1)

#define DECLARE_64_SQUARES(P,g,prev,pref) \
    DECLARE_32_SQUARES(P,g,prev,pref##0) \
    DECLARE_32_SQUARES(P,g,pref##011111,pref##1)

#define DECLARE_128_SQUARES(P,g,prev,pref) \
    DECLARE_64_SQUARES(P,g,prev,pref##0) \
    DECLARE_64_SQUARES(P,g,pref##0111111,pref##1)

#define DECLARE_256_SQUARES(P,g,prev,pref) \
    DECLARE_128_SQUARES(P,g,prev,pref##0) \
    DECLARE_128_SQUARES(P,g,pref##01111111,pref##1)

#define DECLARE_512_SQUARES(P,g,prev,pref) \
    DECLARE_256_SQUARES(P,g,prev,pref##0) \
    DECLARE_256_SQUARES(P,g,pref##011111111,pref##1)

#define MODPOW_STEP(P,g,e,n,acc,pow2,sofar) \
        modpow_step(P,g,e,n,acc,pow2,sofar); \
        if((e/pow2)%2 != 0) { sofar = (acc*sofar)%P; } \
        pow2 = 2*pow2; n = succ(n);

#define MODPOW_STEP2(P,g,e,n,prev_acc,acc,pow2,sofar) \
        modpow_step_by_2(P,g,e,n_##prev_acc,prev_acc,p2_##prev_acc,sofar); \
        if((e/p2_##prev_acc)%2 != 0) { sofar = ((prev_acc)*sofar)%P; } \
        if((e/(p2_##acc##0))%2 != 0) { sofar = ((acc##0)*sofar)%P; } \
        n = n_##acc##1; \

#define MODPOW_STEP4(P,g,e,n,prev_acc,acc,pow2,sofar) \
        MODPOW_STEP2(P,g,e,n,prev_acc,acc##0,pow2,sofar) \
        MODPOW_STEP2(P,g,e,n,acc##01, acc##1,pow2,sofar) \

#define MODPOW_STEP8(P,g,e,n,prev_acc,acc,pow2,sofar) \
        MODPOW_STEP4(P,g,e,n,prev_acc, acc##0,pow2,sofar) \
        MODPOW_STEP4(P,g,e,n,acc##011, acc##1,pow2,sofar) \

#define MODPOW_STEP16(P,g,e,n,prev_acc,acc,pow2,sofar) \
        MODPOW_STEP8(P,g,e,n,prev_acc,  acc##0,pow2,sofar) \
        MODPOW_STEP8(P,g,e,n,acc##0111, acc##1,pow2,sofar) \

#define MODPOW_STEP32(P,g,e,n,prev_acc,acc,pow2,sofar) \
        MODPOW_STEP16(P,g,e,n,prev_acc,   acc##0,pow2,sofar) \
        if(e/(p2_##acc##01111) != 0) { \
            MODPOW_STEP16(P,g,e,n,acc##01111, acc##1,pow2,sofar) \
        }

#define MODPOW_STEP64(P,g,e,n,prev_acc,acc,pow2,sofar) \
        MODPOW_STEP32(P,g,e,n,prev_acc,    acc##0,pow2,sofar) \
        if(e/(p2_##acc##011111) != 0) { \
            MODPOW_STEP32(P,g,e,n,acc##011111, acc##1,pow2,sofar) \
        }

#define MODPOW_STEP128(P,g,e,n,prev_acc,acc,pow2,sofar) \
        MODPOW_STEP64(P,g,e,n,prev_acc,     acc##0,pow2,sofar) \
        if(e/(p2_##acc##0111111) != 0) { \
            MODPOW_STEP64(P,g,e,n,acc##0111111, acc##1,pow2,sofar) \
        }

#define MODPOW_STEP256(P,g,e,n,prev_acc,acc,pow2,sofar) \
        MODPOW_STEP128(P,g,e,n,prev_acc,     acc##0,pow2,sofar) \
        if(e/(p2_##acc##01111111) != 0) { \
            MODPOW_STEP128(P,g,e,n,acc##01111111, acc##1,pow2,sofar) \
        }

#define MODPOW_STEP512(P,g,e,n,prev_acc,acc,pow2,sofar) \
        MODPOW_STEP256(P,g,e,n,prev_acc,      acc##0,pow2,sofar) \
        if(e/(p2_##acc##011111111) != 0) { \
            MODPOW_STEP256(P,g,e,n,acc##011111111, acc##1,pow2,sofar) \
        }

#define MODPOW_FULL_NO_SQUARES(p,g,E,N_BITS) { \
        int e = E; \
        int sofar = 1; \
        int prev_sofar; \
        nat n = zero; \
        note_eq(sofar,modpow(p,g,e,n));\
 \
        MODPOW_STEP##N_BITS(p,g,e,n,g,acc,pow2,sofar) \
        modpowp_correct(p,g,e,n); \
    }

#define MODPOW_FULL(p,g,E,N_BITS) { \
        nat n_##g = zero; \
        int p2_##g = 1; \
        DECLARE_##N_BITS##_SQUARES(p,g,g,acc) \
        MODPOW_FULL_NO_SQUARES(p,g,E,N_BITS) \
    }

#define PRATT_FACTOR(p,g,q,N_BITS) \
    if(!pratt_pow_thing(p,g,q)) { \
        MODPOW_FULL_NO_SQUARES(p,g,(p-1)/q,N_BITS) \
        pratt_pow_thing_auto(p,g,q); \
 \
        assert false; \
    }

#define PRATT_BUILD_PRELUDE(this_P,this_g) \
    int P = this_P; int g = this_g; \
    p25519_##this_P##_g##this_g##_generates(); \
    p25519_##this_P##_1_factors(); \
    p25519_##this_P##_g##this_g##_exact_order(); \
    int f; \
    pratt_cert ret; \
    pratt_cert cert; \
    list<pair<int,pratt_cert> > fact = nil; \
    close pratt_certificate(pratt_cert(g,fact),P-1,N0,P);

#define PRATT_BUILD_SMALL(F) \
    f = F; \
    cert = pratt_small(f); \
    close pratt_certificate(cert,1,zero,f); \
    ret = pratt_certificate_build(g,fact,f,P); \
    fact = cons(pair(f,cert),fact);

#define PRATT_BUILD_BIG(F) \
    f = F; \
    cert = p25519_##F##_pratt(); \
    ret = pratt_certificate_build(g,fact,f,P); \
    fact = cons(pair(f,cert),fact);


#endif

