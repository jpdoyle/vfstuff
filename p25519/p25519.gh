#ifndef VFUTIL_P25519_GH
#define VFUTIL_P25519_GH

#include "../util.gh"
#include "../numtheo.gh"
#include "../finfield.gh"

fixpoint int P25519() {
    return pow_nat(2,nat_of_int(255)) - 19;
}

fixpoint int P448() {
    return pow_nat(2,nat_of_int(448)) - pow_nat(2,nat_of_int(224)) - 1;
}

lemma void p25519_formula();
    requires true;
    ensures  P25519
        ==   pow_nat(pow_nat(2,N15),N16)*pow_nat(2,N15) - 19;

lemma pratt_cert p25519_pratt();
    requires true;
    ensures  pratt_certificate(result,1,_,P25519);

lemma void p25519_is_prime();
    requires true;
    ensures  !!is_prime(P25519);

lemma void p448_formula();
    requires true;
    ensures  P448
        ==   pow_nat(pow_nat(pow_nat(2,N8),N8),N7)
        -    pow_nat(pow_nat(pow_nat(2,N8),N4),N7)
        -    1;

lemma pratt_cert p448_pratt();
    requires true;
    ensures  pratt_certificate(result,1,_,P448);

lemma void p448_is_prime();
    requires true;
    ensures  !!is_prime(P448);

#define DECLARE_2_NATS(prev,pref) \
    nat n##pref##0 = succ(prev); \
    nat n##pref##1 = succ(n##pref##0);

#define DECLARE_4_NATS(prev,pref) \
    DECLARE_2_NATS(prev,pref##0) \
    DECLARE_2_NATS(n##pref##0##1,pref##1)

#define DECLARE_8_NATS(prev,pref) \
    DECLARE_4_NATS(prev,pref##0) \
    DECLARE_4_NATS(n##pref##0##11,pref##1)

#define DECLARE_16_NATS(prev,pref) \
    DECLARE_8_NATS(prev,pref##0) \
    DECLARE_8_NATS(n##pref##0##111,pref##1)

#define DECLARE_32_NATS(prev,pref) \
    DECLARE_16_NATS(prev,pref##0) \
    DECLARE_16_NATS(n##pref##0##1111,pref##1)

#define DECLARE_64_NATS(prev,pref) \
    DECLARE_32_NATS(prev,pref##0) \
    DECLARE_32_NATS(n##pref##0##11111,pref##1)

#define DECLARE_128_NATS(prev,pref) \
    DECLARE_64_NATS(prev,pref##0) \
    DECLARE_64_NATS(n##pref##0##111111,pref##1)

#define DECLARE_256_NATS(prev,pref) \
    DECLARE_128_NATS(prev,pref##0) \
    DECLARE_128_NATS(n##pref##0##1111111,pref##1)

#define DECLARE_512_NATS(prev,pref) \
    DECLARE_256_NATS(prev,pref##0) \
    DECLARE_256_NATS(n##pref##0##11111111,pref##1)

#define MODPOW_STEP(P,g,e,n,acc,pow2,sofar) \
        modpow_step(P,g,e,n,acc,pow2,sofar); \
        if((e/pow2)%2 != 0) { sofar = (acc*sofar)%P; } \
        acc = (acc*acc)%P; pow2 = 2*pow2; n = succ(n);

#define MODPOW_STEP2(P,g,e,n,acc,pow2,sofar) \
        modpow_step_by_2(P,g,e,n,acc,pow2,sofar); \
        if((e/pow2)%2 != 0) { sofar = (acc*sofar)%P; } \
        acc = (acc*acc)%P; \
        if((e/(2*pow2))%2 != 0) { sofar = (acc*sofar)%P; } \
        acc = (acc*acc)%P; pow2 = 4*pow2; n = succ(succ(n)); \

#define MODPOW_STEP4(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP2(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP2(P,g,e,n,acc,pow2,sofar)

#define MODPOW_STEP8(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP4(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP4(P,g,e,n,acc,pow2,sofar)

#define MODPOW_STEP16(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP8(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP8(P,g,e,n,acc,pow2,sofar)

#define MODPOW_STEP32(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP16(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP16(P,g,e,n,acc,pow2,sofar)

#define MODPOW_STEP64(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP32(P,g,e,n,acc,pow2,sofar) \
        if(e/pow2 != 0) { \
            MODPOW_STEP32(P,g,e,n,acc,pow2,sofar) \
        }

#define MODPOW_STEP128(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP64(P,g,e,n,acc,pow2,sofar) \
        if(e/pow2 != 0) { \
            MODPOW_STEP64(P,g,e,n,acc,pow2,sofar) \
        }

#define MODPOW_STEP256(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP128(P,g,e,n,acc,pow2,sofar) \
        if(e/pow2 != 0) { \
            MODPOW_STEP128(P,g,e,n,acc,pow2,sofar) \
        }

#define MODPOW_STEP512(P,g,e,n,acc,pow2,sofar) \
        MODPOW_STEP256(P,g,e,n,acc,pow2,sofar) \
        if(e/pow2 != 0) { \
            MODPOW_STEP256(P,g,e,n,acc,pow2,sofar) \
        }

#define MODPOW_FULL(p,g,E,N_BITS) { \
        int e = E; \
        int acc = g; \
        int pow2 = 1; \
        int sofar = 1; \
        nat n = zero; \
 \
        MODPOW_STEP##N_BITS(p,g,e,n,acc,pow2,sofar) \
        modpowp_correct(p,g,e,n); \
    }

#define PRATT_FACTOR(p,g,q,N_BITS) \
    if(!pratt_pow_thing(p,g,q)) { \
        MODPOW_FULL(p,g,(p-1)/q,N_BITS) \
        pratt_pow_thing_auto(p,g,q); \
 \
        assert false; \
    }

#define PRATT_BUILD_PRELUDE(this_P,this_g) \
    int P = this_P; int g = this_g; \
    p25519_##this_P##_g##this_g##_generates(); \
    p25519_##this_P##_1_factors(); \
    p25519_##this_P##_g##this_g##_exact_order(); \
    int f; \
    pratt_cert ret; \
    pratt_cert cert; \
    list<pair<int,pratt_cert> > fact = nil; \
    close pratt_certificate(pratt_cert(g,fact),P-1,N0,P);

#define PRATT_BUILD_SMALL(F) \
    f = F; \
    cert = pratt_small(f); \
    close pratt_certificate(cert,1,zero,f); \
    ret = pratt_certificate_build(g,fact,f,P); \
    fact = cons(pair(f,cert),fact);

#define PRATT_BUILD_BIG(F) \
    f = F; \
    cert = p25519_##F##_pratt(); \
    ret = pratt_certificate_build(g,fact,f,P); \
    fact = cons(pair(f,cert),fact);


#endif

