/***************************************************************
    Bitops.gh from verifast's master branch (commit
    51f686a41f9bc8dd6cf5cd74f18d4316344799ce) with minor tweaks.

All modifications of this file are Copyright (c) 2019 Joseph Doyle and
are distributed under the GNU LGPLv3, as provided in LICENSE.md.

Its original LICENSE.md file:

 ***************************************************************

VeriFast

Copyright (c) 2008-2016 Katholieke Universiteit Leuven

The MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


 ***************************************************************
 */


#ifndef BITOPS_GH
#define BITOPS_GH

#include <nat.gh>
#include "util.gh"

// Definitions

inductive Z = Zsign(bool) | Zdigit(Z, bool);

fixpoint int int_of_Z(Z z) {
    switch (z) {
        case Zsign(b): return (b) ? -1 : 0;
        case Zdigit(z0, b0): return 2 * int_of_Z(z0) + ((b0) ? 1 : 0);
    }
}

fixpoint Z Z_and(Z z1, Z z2) {
    switch (z1) {
        case Zsign(b1): return (b1) ? z2 : z1;
        case Zdigit(z10, b10): return switch (z2) {
            case Zsign(b2): return (b2) ? z1 : z2;
            case Zdigit(z20, b20): return Zdigit(Z_and(z10, z20), (b10) && (b20));
        };
    }
}

lemma void bitand_def(int x1, Z z1, int x2, Z z2);
    requires x1 == int_of_Z(z1) &*& x2 == int_of_Z(z2);
    ensures (x1 & x2) == int_of_Z(Z_and(z1, z2));

fixpoint Z Z_not(Z z) {
    switch (z) {
        case Zsign(b): return Zsign(!(b));
        case Zdigit(z0, b0): return Zdigit(Z_not(z0), !(b0));
    }
}

lemma void bitnot_def(int x, Z z);
    requires x == int_of_Z(z);
    ensures ~x == int_of_Z(Z_not(z));

fixpoint Z Z_xor(Z z1, Z z2) {
    switch (z1) {
        case Zsign(b1): return (b1) ? Z_not(z2) : z2;
        case Zdigit(z10, b10): return switch (z2) {
            case Zsign(b2): return (b2) ? Z_not(z1) : z1;
            case Zdigit(z20, b20): return Zdigit(Z_xor(z10, z20), b10 != b20);
        };
    }
}

lemma void bitxor_def(int x1, Z z1, int x2, Z z2);
    requires x1 == int_of_Z(z1) &*& x2 == int_of_Z(z2);
    ensures (x1 ^ x2) == int_of_Z(Z_xor(z1, z2));

fixpoint Z Z_or(Z z1, Z z2) {
    switch (z1) {
        case Zsign(b1): return (b1) ? z1 : z2;
        case Zdigit(z10, b10): return switch (z2) {
            case Zsign(b2): return (b2) ? z2 : z1;
            case Zdigit(z20, b20): return Zdigit(Z_or(z10, z20), (b10) || (b20));
        };
    }
}

lemma void bitor_def(int x1, Z z1, int x2, Z z2);
    requires x1 == int_of_Z(z1) &*& x2 == int_of_Z(z2);
    ensures (x1 | x2) == int_of_Z(Z_or(z1, z2));

lemma void shiftleft_def(int x, nat n);
    requires true;
    ensures x << int_of_nat(n) == x * pow_nat(2, n);

fixpoint Z Z_shiftright(Z z, nat n) {
    switch (n) {
        case zero: return z;
        case succ(n0): return switch (z) {
            case Zsign(b): return z;
            case Zdigit(z0, b0): return Z_shiftright(z0, n0);
        };
    }
}

lemma void shiftright_def(int x, Z z, nat n);
    requires x == int_of_Z(z);
    ensures x >> int_of_nat(n) == int_of_Z(Z_shiftright(z, n));

lemma void truncate_unsigned_def(int x, nat n);
    requires true;
    ensures truncate_unsigned(x, int_of_nat(n)) == x % pow_nat(2, n);

lemma_auto(truncate_unsigned(x,nb)) void truncate_unsigned_def_auto(int x, int nb)
    requires nb >= 0;
    ensures truncate_unsigned(x, nb) == x % pow_nat(2, nat_of_int(nb));
{
    truncate_unsigned_def(x,nat_of_int(nb));
    int_of_nat_of_int(nb);
}

fixpoint Z Z_truncate_signed(Z z, nat n) { // n = number of bits, not including the sign bit!
    switch (n) {
        case zero: return switch (z) {
            case Zsign(b): return z;
            case Zdigit(z0, b0): return Zsign(b0);
        };
        case succ(n0): return switch (z) {
            case Zsign(b): return Zdigit(Z_truncate_signed(z, n0), b);
            case Zdigit(z0, b0): return Zdigit(Z_truncate_signed(z0, n0), b0);
        };
    }
}

lemma void truncate_signed_def(int x, Z z, nat n);
    requires x == int_of_Z(z);
    ensures truncate_signed(x, int_of_nat(n)) == int_of_Z(Z_truncate_signed(z, n));

// Limits

lemma void bitand_limits(int x, int y, nat n);
    requires 0 <= x && x < pow_nat(2, n) || 0 <= y && y < pow_nat(2, n);
    ensures 0 <= (x & y) &*& (x & y) < pow_nat(2, n);

lemma void bitand_signed_limits(int x, int y, nat n);
    requires -pow_nat(2, n) <= x && x < pow_nat(2, n) || -pow_nat(2, n) <= y && y < pow_nat(2, n);
    ensures -pow_nat(2, n) <= (x & y) &*& (x & y) < pow_nat(2, n);

lemma void bitxor_limits(int x, int y, nat n);
    requires 0 <= x &*& x < pow_nat(2, n) &*& 0 <= y &*& y < pow_nat(2, n);
    ensures 0 <= (x ^ y) &*& (x ^ y) < pow_nat(2, n);

lemma void bitxor_signed_limits(int x, int y, nat n);
    requires -pow_nat(2, n) <= x &*& x < pow_nat(2, n) &*& -pow_nat(2, n) <= y &*& y < pow_nat(2, n);
    ensures -pow_nat(2, n) <= (x | y) &*& (x | y) < pow_nat(2, n);

lemma void bitor_limits(int x, int y, nat n);
    requires 0 <= x &*& x < pow_nat(2, n) &*& 0 <= y &*& y < pow_nat(2, n);
    ensures 0 <= (x | y) &*& (x | y) < pow_nat(2, n);

lemma void bitor_signed_limits(int x, int y, nat n);
    requires -pow_nat(2, n) <= x &*& x < pow_nat(2, n) &*& -pow_nat(2, n) <= y &*& y < pow_nat(2, n);
    ensures -pow_nat(2, n) <= (x | y) &*& (x | y) < pow_nat(2, n);

lemma void shiftleft_limits(int x, nat m, nat n);
    requires 0 <= x &*& x < pow_nat(2, m);
    ensures 0 <= x << int_of_nat(n) &*& x << int_of_nat(n) < pow_nat(2, nat_plus(m, n));

lemma void shiftleft_signed_limits(int x, nat m, nat n);
    requires -pow_nat(2, m) <= x &*& x < pow_nat(2, m);
    ensures -pow_nat(2, nat_plus(m, n)) <= x << int_of_nat(n) &*& x << int_of_nat(n) < pow_nat(2, nat_plus(m, n));

lemma void shiftright_limits(int x, nat m, nat n);
    requires 0 <= x &*& x < pow_nat(2, m);
    ensures 0 <= x >> int_of_nat(n) &*& x >> int_of_nat(n) < pow_nat(2, nat_minus(m, n));

lemma void shiftright_signed_limits(int x, nat m, nat n);
    requires -pow_nat(2, m) <= x &*& x < pow_nat(2, m);
    ensures -pow_nat(2, nat_minus(m, n)) <= x >> int_of_nat(n) &*& x >> int_of_nat(n) < pow_nat(2, nat_minus(m, n));

lemma void truncate_limits(int x, nat n);
    requires true;
    ensures 0 <= truncate_unsigned(x, int_of_nat(n)) &*& truncate_unsigned(x, int_of_nat(n)) < pow_nat(2, n);

lemma void truncate_signed_limits(int x, nat n);
    requires true;
    ensures -pow_nat(2, n) <= truncate_signed(x, int_of_nat(n)) &*& truncate_signed(x, int_of_nat(n)) < pow_nat(2, n);

// Bit blasting

fixpoint pair<int, list<bool> > bits_of_int(int x, nat n) {
    switch (n) {
        case zero: return pair(x, nil);
        case succ(n0): return pair(fst(bits_of_int(x / 2, n0)), cons(x % 2 == 1, snd(bits_of_int(x / 2, n0))));
    }
}

fixpoint int int_of_bits(int xh, list<bool> bits) {
    switch (bits) {
        case nil: return xh;
        case cons(b, bs0): return 2 * int_of_bits(xh, bs0) + ((b) ? 1 : 0);
    }
}

lemma void int_of_bits_of_int(int x, nat n)
    requires 0 <= x;
    ensures x == int_of_bits(fst(bits_of_int(x, n)), snd(bits_of_int(x, n)));
{
    switch (n) {
        case zero:
        case succ(n0):
            div_rem(x, 2);
            int_of_bits_of_int(x / 2, n0);
            note(bounded(0,1,x%2));
    }
}

fixpoint Z Z_of_bits(Z zh, list<bool> bits) {
    switch (bits) {
        case nil: return zh;
        case cons(b, bs0): return Zdigit(Z_of_bits(zh, bs0), b);
    }
}

lemma Z Z_of_uintN(int x, nat N)
    requires 0 <= x &*& x < pow_nat(2, N);
    ensures result == Z_of_bits(Zsign(false), snd(bits_of_int(x, N))) &*& x == int_of_Z(result);
{
    switch (N) {
        case zero:
            return Zsign(false);
        case succ(N0):
            div_rem(x, 2);
            Z_of_uintN(x / 2, N0);
            int_of_bits_of_int(x, N);
            note(!!bounded(0,1,x%2));
            return Z_of_bits(Zsign(false), snd(bits_of_int(x, N)));
    }
}

lemma Z Z_of_uint8(int x)
    requires 0 <= x &*& x <= 255;
    ensures result == Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zsign(false), _), _), _), _), _), _), _), _) &*& x == int_of_Z(result);
{
    return Z_of_uintN(x, N8);
}

//lemma Z Z_of_uint16(int x)
//    requires 0 <= x &*& x <= 65535;
//    ensures result == Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zsign(false), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _) &*& x == int_of_Z(result);
//{
//    return Z_of_uintN(x, N16);
//}
//
//lemma Z Z_of_uint32(int x)
//    requires 0 <= x &*& x <= 0xffffffff;
//    ensures result == Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zdigit(Zsign(false), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _), _) &*& x == int_of_Z(result);
//{
//    return Z_of_uintN(x, N32);
//}

lemma_auto(Z_or(x_Z,y_Z))
void Z_or_commutes(Z x_Z, Z y_Z)
    requires true;
    ensures  Z_or(x_Z,y_Z) == Z_or(y_Z,x_Z);
{
    switch(y_Z) {
    case Zsign(sy):
        switch(x_Z) {
        case Zsign(sx):
        case Zdigit(x_z0,xb):
        }
    case Zdigit(y_z0,yb):
        switch(x_Z) {
        case Zsign(sx):
        case Zdigit(x_z0,xb):
            Z_or_commutes(x_z0,y_z0);
            note_eq( xb || yb , yb || xb);
        }
    }
}

lemma void Z_or_zero(Z x_Z, Z y_Z)
    requires int_of_Z(y_Z) == 0;
    ensures  int_of_Z(Z_or(x_Z,y_Z)) == int_of_Z(x_Z);
{
    switch(y_Z) {
    case Zsign(sy):
        switch(x_Z) {
        case Zsign(sx):
        case Zdigit(x_z0,xb):
        }
    case Zdigit(y_z0,yb):
        switch(x_Z) {
        case Zsign(sx):
        case Zdigit(x_z0,xb):
            division_zero_unique(2,int_of_Z(y_z0),((yb) ? 1 : 0));
            Z_or_zero(x_z0,y_z0);
        }
    }
}

lemma void bitor_no_overlap_inner(int x, Z x_Z, int y, Z y_Z, nat n)
    requires x >= 0 &*& y >= 0 &*& y < pow_nat(2,n)
        &*&  int_of_Z(x_Z) == x*pow_nat(2,n) &*& int_of_Z(y_Z) == y
        ;
    ensures  (x*pow_nat(2,n) | y) == x*pow_nat(2,n) + y;
{
    switch(n) {
    case zero:
        bitor_def(x*pow_nat(2,n), x_Z, y, y_Z);
        Z_or_zero(x_Z,y_Z);
    case succ(n0):
        bitor_def(x*pow_nat(2,n), x_Z, y, y_Z);
        mul_3var(2,x,pow_nat(2,n0));
        division_unique(x*pow_nat(2,n),2,x*pow_nat(2,n0),0);

        switch(y_Z) {
        case Zsign(s):
            Z_or_zero(x_Z,y_Z);
        case Zdigit(y_z0,yb):
            switch(x_Z) {
            case Zsign(s):
                if(!s) {
                    Z_or_zero(y_Z,x_Z);
                } else {
                    assert int_of_Z(x_Z) == x*pow_nat(2,n);
                    assert int_of_Z(x_Z) == -1;
                    division_unique(x*pow_nat(2,n),2,0,-1);
                    assert false;
                }
            case Zdigit(x_z0,xb):
                assert (x*pow_nat(2,n))%2 == 0;
                div_rem(y,2);

                assert (xb?1:0) >= 0;
                assert (xb?1:0) <= 1;

                if(int_of_Z(x_z0) < 0) {
                    assert x >= 0;
                    assert pow_nat(2,n) >= 0;
                    my_mul_mono_l(0,x,pow_nat(2,n));
                    assert x*pow_nat(2,n) >= 0;
                    my_mul_mono_r(2,int_of_Z(x_z0),1);
                    assert false;
                }

                if(int_of_Z(y_z0) < 0) {
                    assert false;
                }

                mul_abs_commute(2,int_of_Z(x_z0));
                division_unique(x*pow_nat(2,n),2,int_of_Z(x_z0),
                        xb ? 1 : 0);
                assert xb == false;

                assert Z_or(x_Z,y_Z)
                    == Zdigit(Z_or(x_z0,y_z0),
                                (xb) || (yb));

                division_unique(y,2,int_of_Z(y_z0),yb?1:0);
                assert int_of_Z(y_z0) == y/2;

                bitor_no_overlap_inner(x, x_z0, (y/2),
                        y_z0, n0);
                bitor_def(x*pow_nat(2,n0), x_z0, y/2, y_z0);

                assert Z_or(x_Z,y_Z)
                    == Zdigit(Z_or(x_z0,y_z0), yb);
                assert int_of_Z(Z_or(x_Z,y_Z))
                    == y%2 + 2*(x*pow_nat(2,n0) + y/2);
                assert int_of_Z(Z_or(x_Z,y_Z))
                    == (y%2 + 2*(y/2)) + 2*(x*pow_nat(2,n0));
                assert int_of_Z(Z_or(x_Z,y_Z))
                    == y + x*pow_nat(2,n);
            }
        }
    }
}

fixpoint nat log_nat_inner(int x,nat n) {
    switch(n) {
    case zero: return zero;
    case succ(n0):
        return (x == 0 ? zero : succ(log_nat_inner(x/2,n0)));
    }
}

fixpoint nat log_nat(int x) {
    return log_nat_inner(x,nat_of_int(abs(x)));
}

lemma_auto(log_nat_inner(x,n))
void log_nat_prop_inner(int x, nat n)
    requires abs(x) <= int_of_nat(n);
    ensures  pow_nat(2,log_nat_inner(x,n)) > abs(x);
{
    switch(n) {
    case zero:
    case succ(n0):
        if(x != 0) {
            div_rem(x,2);
            log_nat_prop_inner(x/2,n0);
            assert abs(x/2) < pow_nat(2,log_nat_inner(x,n));
            my_mul_mono_r(2,abs(x/2)+1,pow_nat(2,log_nat_inner(x,n)));
        }
    }
}

lemma_auto(log_nat(x))
void log_nat_prop(int x)
    requires true;
    ensures  pow_nat(2,log_nat(x)) > abs(x);
{ log_nat_prop_inner(x,nat_of_int(abs(x))); }

lemma void bitor_no_overlap(int x, int y, nat n)
    requires x >= 0 &*& y >= 0 &*& y < pow_nat(2,n);
    ensures  (x*pow_nat(2,n) | y) == x*pow_nat(2,n) + y;
{
    nat lgY = log_nat(y);
    my_mul_mono_l(0,x,pow_nat(2,n));
    Z x_Z = Z_of_uintN(x*pow_nat(2,n),log_nat(x*pow_nat(2,n)));
    Z y_Z = Z_of_uintN(y,lgY);
    bitor_no_overlap_inner(x, x_Z, y, y_Z, n);
}

lemma void Z_and_zero(Z x_Z, Z y_Z)
    requires int_of_Z(y_Z) == 0;
    ensures  int_of_Z(Z_and(x_Z,y_Z)) == 0;
{
    switch(y_Z) {
    case Zsign(sy):
        switch(x_Z) {
        case Zsign(sx):
        case Zdigit(x_z0,xb):
        }
    case Zdigit(y_z0,yb):
        switch(x_Z) {
        case Zsign(sx):
        case Zdigit(x_z0,xb):
            division_zero_unique(2,int_of_Z(y_z0),((yb) ? 1 : 0));
            Z_and_zero(x_z0,y_z0);
        }
    }
}

lemma void bitand_pow_2_inner(int x, Z x_Z, Z y_Z, nat n)
    requires x >= 0 &*& int_of_Z(x_Z) == x
        &*& int_of_Z(y_Z) == pow_nat(2,n)-1
        &*& n != zero;
    ensures  (x & (pow_nat(2,n)-1)) == x%pow_nat(2,n);
{
    switch(n) {
    case zero:
    case succ(n0):
        bitand_def(x,x_Z,pow_nat(2,n)-1,y_Z);
        if(n0 != zero) {
            switch(y_Z) {
            case Zsign(sy):
                switch(x_Z) {
                case Zsign(sx): assert !sx;
                case Zdigit(x_z0,xb):
                }
            case Zdigit(y_z0,yb):
                division_unique(pow_nat(2,n)-1,2,pow_nat(2,n0)-1,1);
                division_unique(pow_nat(2,n)-1,2,int_of_Z(y_z0),yb?1:0);
                assert !!yb;
                switch(x_Z) {
                case Zsign(sx):
                    assert !sx;
                    assert int_of_Z(Z_and(x_Z,y_Z)) == 0;
                    assert (x&(pow_nat(2,n)-1)) == 0;
                    division_zero_unique(pow_nat(2,n),0,0);
                case Zdigit(x_z0,xb):
                    div_rem(x,2);
                    div_rem(x/2,pow_nat(2,n0));
                    assert x/2 >= 0;

                    if(int_of_Z(x_z0) < 0) {
                        assert false;
                    }

                    division_unique(x,2,int_of_Z(x_z0),xb?1:0);
                    bitand_pow_2_inner(x/2,x_z0,y_z0,n0);
                    bitand_def(x/2,x_z0,pow_nat(2,n0)-1,y_z0);

                    assert (x/2)%pow_nat(2,n0)
                        == int_of_Z(Z_and(x_z0,y_z0));
                    my_mul_mono_r(2,int_of_Z(Z_and(x_z0,y_z0)),pow_nat(2,n0)-1);

                    assert pow_nat(2,n)*((x/2)/pow_nat(2,n0))
                        == (2*pow_nat(2,n0))*((x/2)/pow_nat(2,n0));
                    mul_assoc(2,pow_nat(2,n0),(x/2)/pow_nat(2,n0));
                    my_mul_mono_r(2,pow_nat(2,n0)*((x/2)/pow_nat(2,n0)),x/2);
                    assert pow_nat(2,n)*((x/2)/pow_nat(2,n0)) <= x;

                    division_unique(x,pow_nat(2,n),(x/2)/pow_nat(2,n0),
                        2*int_of_Z(Z_and(x_z0,y_z0)) + (xb?1:0));
                }
            }
        } else {
            assert int_of_Z(y_Z) == 1;
            division_unique(1,2,0,1);
            switch(y_Z) {
            case Zsign(ys):
            case Zdigit(y_z0,yb):
                division_unique(1,2,int_of_Z(y_z0),yb?1:0);
                switch(x_Z) {
                case Zsign(sx):
                    assert !sx;
                    division_unique(x,2,0,0);
                case Zdigit(x_z0,xb):
                    Z_and_zero(x_z0,y_z0);
                    div_rem(x,2);

                    if(int_of_Z(x_z0) < 0) {
                        assert false;
                    }

                    division_unique(x,2,int_of_Z(x_z0),xb?1:0);
                }
            }
        }
    }
}

lemma void bitand_pow_2(int x, nat n)
    requires x >= 0 &*& n != zero;
    ensures  (x & (pow_nat(2,n)-1)) == x%pow_nat(2,n);
{ bitand_pow_2_inner(x,Z_of_uintN(x,log_nat(x)),
                     Z_of_uintN(pow_nat(2,n)-1,n),n); }

lemma void shiftright_div_inner(Z x_Z, nat n)
    requires int_of_Z(x_Z) >= 0;
    ensures  int_of_Z(Z_shiftright(x_Z,n))
        ==   int_of_Z(x_Z)/pow_nat(2,n);
{
    switch(n) {
    case zero:
        division_unique(int_of_Z(x_Z),1,int_of_Z(x_Z),0);
    case succ(n0):
        switch(x_Z) {
        case Zsign(b):
            division_unique(0,pow_nat(2,n),0,0);
        case Zdigit(x_z0,xb):
            shiftright_div_inner(x_z0,n0);

            if(int_of_Z(x_z0) < 0) {
                assert false;
            }

            int x = int_of_Z(x_Z);
            div_rem(x,2);
            div_rem(x/2,pow_nat(2,n0));
            division_unique(x,2,int_of_Z(x_z0),xb?1:0);
            mul_assoc(2,pow_nat(2,n0),(x/2)/pow_nat(2,n0));
            my_mul_mono_r(2,pow_nat(2,n0)*((x/2)/pow_nat(2,n0)),x/2);
            div_rem(int_of_Z(x_z0),pow_nat(2,n0));

            division_unique(x,pow_nat(2,n),
                    (int_of_Z(x_z0))/pow_nat(2,n0),
                    2*(int_of_Z(x_z0)%pow_nat(2,n0)) + (xb?1:0));
        }
    }
}

lemma void shiftright_div(int x, nat n)
    requires x >= 0;
    ensures  x>>int_of_nat(n) == x/pow_nat(2,n);
{
    Z x_Z = Z_of_uintN(x,log_nat(x));
    shiftright_def(x,x_Z,n);
    shiftright_div_inner(x_Z,n);
}

#endif
